---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 13-transform-data.md in _episodes_rmd/
source: Rmd
title: "Data Transformation"
teaching: 0
exercises: 0
questions:
- "How do I transform data?"
objectives:
- "Add new columns to a data frame that are functions of existing columns with `mutate`."
- "Use the split-apply-combine concept for data analysis."
- "Use `summarize`, `group_by`, and `count` to split a data frame into groups of observations, apply summary statistics for each group, and then combine the results."
keypoints:
- ""
- ""
---


```r
library(tidyverse)
```

```
## ── Attaching packages ──────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.0 ──
```

```
## ✔ ggplot2 3.3.3     ✔ purrr   0.3.4
## ✔ tibble  3.1.0     ✔ dplyr   1.0.5
## ✔ tidyr   1.1.3     ✔ stringr 1.4.0
## ✔ readr   1.4.0     ✔ forcats 0.5.1
```

```
## ── Conflicts ─────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
```

### Mutate

Frequently you'll want to create new columns based on the values in existing
columns, for example to do unit conversions, or to find the ratio of values in two
columns. For this we'll use `mutate()`.

To create a new column of tumor size (volume) in cubic centimeters:


```r
tumor %>%
  mutate(size_cubic_cm = Size / 1000)
```

```
## Error in mutate(., size_cubic_cm = Size/1000): object 'tumor' not found
```

You can also create a second new column based on the first new column within the same call of `mutate()`:


```r
tumor %>%
  mutate(size_cubic_cm = Size / 1000,
         size_cubic_in = size_cubic_cm / 16)
```

```
## Error in mutate(., size_cubic_cm = Size/1000, size_cubic_in = size_cubic_cm/16): object 'tumor' not found
```

If this runs off your screen and you just want to see the first few rows, you
can use a pipe to view the `head()` of the data. (Pipes work with non-**`dplyr`**
functions, too, as long as the **`dplyr`** or `magrittr` package is loaded).


```r
tumor %>%
  mutate(size_cubic_cm = Size / 1000) %>%
  head()
```

```
## Error in mutate(., size_cubic_cm = Size/1000): object 'tumor' not found
```

> ### Challenge {.challenge}
>
>  Create a new data frame from the `surveys` data that meets the following
>  criteria: contains only the `Grp` column and a new column called
>  `size_cubic_in` containing the `Size` values converted to cubic inches.
>  In this `size_cubic_in` column, all values are greater than 0.1.
>
>  **Hint**: think about how the commands should be ordered to produce this data frame!
> 
> 
> ```r
> tumor_cubic_in <- tumor %>%
>     mutate(size_cubic_cm = Size / 1000,
>          size_cubic_in = size_cubic_cm / 16) %>%
>     filter(size_cubic_in > 0.1) %>%
>     select(Grp, size_cubic_in)
> ```

### Split-apply-combine data analysis and the `summarize()` function

Many data analysis tasks can be approached using the *split-apply-combine*
paradigm: split the data into groups, apply some analysis to each group, and
then combine the results. **`dplyr`** makes this very easy through the use of the
`group_by()` function.


#### The `summarize()` function

`group_by()` is often used together with `summarize()`, which collapses each
group into a single-row summary of that group.  `group_by()` takes as arguments
the column names that contain the **categorical** variables for which you want
to calculate the summary statistics. So to compute the mean `Size` by group:


```r
tumor %>%
  group_by(Grp) %>%
  summarize(mean_size = mean(Size))
```

```
## Error in group_by(., Grp): object 'tumor' not found
```

You can also group by multiple columns:


```r
tumor %>%
  group_by(Grp, Day) %>%
  summarize(mean_size = mean(Size)) %>% 
  tail()
```

```
## Error in group_by(., Grp, Day): object 'tumor' not found
```

Here, we used `tail()` to look at the last six rows of our summary. Before, we had 
used `head()` to look at the first six rows. 

If you want to display more data, you can use the `print()` function
at the end of your chain with the argument `n` specifying the number of rows to
display:


```r
tumor %>%
  group_by(Grp, Day) %>%
  summarize(mean_size = mean(Size)) %>% 
  print(n = 15)
```

```
## Error in group_by(., Grp, Day): object 'tumor' not found
```

Once the data are grouped, you can also summarize multiple variables at the same
time (and not necessarily on the same variable). For instance, we could add a
column indicating the minimum size for each day for each group:


```r
tumor %>%
  group_by(Grp, Day) %>%
  summarize(mean_size = mean(Size),
            min_size = min(Size))
```

```
## Error in group_by(., Grp, Day): object 'tumor' not found
```

To sort in descending order, we need to add the `desc()` function. If we want to sort the results by decreasing order of mean weight:


```r
tumor %>%
  group_by(Grp, Day) %>%
  summarize(mean_size = mean(Size),
            min_size = min(Size)) %>%
  arrange(desc(mean_size))
```

```
## Error in group_by(., Grp, Day): object 'tumor' not found
```


#### Counting

When working with data, we often want to know the number of observations found
for each factor or combination of factors. For this task, **`dplyr`** provides
`count()`. For example, if we wanted to count the number of rows of data for
each group, we would do:


```r
tumor %>%
    count(Grp) 
```

```
## Error in count(., Grp): object 'tumor' not found
```

The `count()` function is shorthand for something we've already seen: grouping by a variable, and summarizing it by counting the number of observations in that group. In other words, `tumor %>% count()` is equivalent to:  


```r
tumor %>%
    group_by(Grp) %>%
    summarise(count = n())
```

```
## Error in group_by(., Grp): object 'tumor' not found
```

For convenience, `count()` provides the `sort` argument:  


```r
tumor %>%
    count(Grp, sort = TRUE) 
```

```
## Error in count(., Grp, sort = TRUE): object 'tumor' not found
```

Previous example shows the use of `count()` to count the number of rows/observations 
for *one* factor (i.e., `Grp`). 
If we wanted to count *combination of factors*, such as `Grp` and `Day`, 
we would specify the first and the second factor as the arguments of `count()`:


```r
tumor %>%
  count(Grp, Day) 
```

```
## Error in count(., Grp, Day): object 'tumor' not found
```

With the above code, we can proceed with `arrange()` to sort the table 
according to a number of criteria so that we have a better comparison. 
For instance, we might want to arrange the table above in (i) an alphabetical order of 
the levels of the group and (ii) in descending order of the count:


```r
tumor %>%
  count(Grp, Day) %>%
  arrange(Day, desc(n))
```

```
## Error in count(., Grp, Day): object 'tumor' not found
```

> ### Challenge {.challenge}
>
> 1. How many observations are there for each `ID` number?
>
> 
> ```r
> tumor %>%
>     count(ID) 
> ```
> 
> ```
> ## Error in count(., ID): object 'tumor' not found
> ```
>
> 2. Use `group_by()` and `summarize()` to find the mean, min, and max tumor
> size for each ID (using `ID`). Also add the number of
> observations (hint: see `?n`).
>
> 
> ```r
> tumor %>%
>     group_by(ID) %>%
>     summarize(
>         mean_size = mean(Size),
>         min_size = min(Size),
>         max_size = max(Size),
>         n = n()
>     )
> ```
> 
> ```
> ## Error in group_by(., ID): object 'tumor' not found
> ```
>
> 3. What was the largest tumor measured in each day? Return the columns `Day`,
> `Grp`, `ID`, and `Size`.
>
> 
> ```r
> tumor %>%
>     group_by(Day) %>%
>     filter(Size == max(Size)) %>%
>     select(Day, Grp, ID, Size) %>%
>     arrange(Day)
> ```
> 
> ```
> ## Error in group_by(., Day): object 'tumor' not found
> ```
